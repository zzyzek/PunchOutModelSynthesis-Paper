\section{Related Work}

To our knowledge, Merrell was the first to introduce the modern formulation of Constraint Based Tiling Generation (CBTG)
\footnote{The term \textit{Constraint Based Tile Generators} was coined by Adam Newgas \cite{BorisTheBrave_cbtg_2021} and have been adopted in this paper,
with slightly different wording, as the name for the specialization of the more general Constraint Satisfaction Problem.}
\cite{Merrell_2007, Merrell_2009}.
Merrell introduced a modify in blocks Model Synthesis (MMS) algorithm that starts with a fully resolved grid
and applies a one shot block level constraint solver on sub-blocks within the grid.

Merrell noticed that the block level algorithm undergoes a phase transition of solvability, with a decreasing probability
for successful block resolution as block size increases.
Instead of attempting to resolve a large grid in one try, the MMS algorithm progressively resolves sub-blocks and re-integrates them back into the grid.
If a block level resolution fails, the block is discarded without altering the grid and another block is chosen.

For many problems, MMS is ideal as it always keeps a full resolution of the grid throughout its run.
Merrell introduced a sequential overlapping schedule for block choice and, for some suitable assumptions
on block size and underlying distribution, the mixing time can be quick, requiring only a few passes through the grid.

Unfortunately, MMS has two major drawbacks, the second of which Merrell noticed and discussed in his thesis:

\begin{itemize}
  \item The requirement of an initially resolved state to start MMS might be difficult to achieve, either in a practical
        or theoretical sense.
  \item Features bigger than the chosen block size will be missed by MMS as there is no way to realize larger features
        through single block level alterations.
\end{itemize}

Many of the tile sets and tile constraints that Merrell provides in \cite{Merrell_2007, Merrell_2009} have an ``empty'' tile that 
has itself as an admissible neighbor, creating a situation where the initial fully resolved grid can be easily created
by populating each cell with an ``empty'' tile.
All 2D tile sets and tile constraints presented in this paper do not have an initial state that can be created through
the replication of just one tile throughout the grid and require some amount of knowledge about the tile constraints
to create a fully resolved grid.

In general, for some tile constraints, finding a class of fully resolved initial configurations might be done through engineering effort.
For example, it might be possible to find a small tileable block that is then able to be replicated through to the whole grid
\footnote{ This method was suggested to the authors through personal communication with P. Merrell }.

For other tile constraints, finding any fully resolved grid from an initially indeterminate state might be the goal.
In such cases, running MMS would defeat the purpose, as MMS can't start without a solution but if a solution is known, MMS wouldn't
be needed.
As an example, a tile set can be constructed where a grid realization connects two endpoints via a path
without explicitely describing where the path meanders through the grid.
MMS would require a full realization of the path before it could start.

%Depending on tile constraints, discovering an initially resolved grid might be a question of engineering
%effort, so might not pose a theoretical impediment to using MMS.

POMS sidesteps the need for a fully realized initial configuration by allowing the grid to be in an indeterminate state.

Note that, to the authors knowledge, no systematic examination of methods or strategies to create initial states
to be fed into MMS has been done.
The above discussion is informed through personal experimentation and through discussion with P. Merrell.

The inability to handle certain types of unbounded constraints, such as the implicit top and bottom equal river count constraint that appear in
Wo\'zniak's \textit{Forest Micro} tile set, is the deeper issue with MMS.
Choosing a small block size for MMS could miss novel features whereas too large of a block size either decreases
the likelihood of block resolution or turns MMS into a block level solver.

%MMS ensures success at the cost of novelty whereas POMS embraces novelty but entertains failure.
%POMS allows for long range implicit constraints, such as unbounded paths or large features, because the grid allows
%for an indeterminate state.
%MMS can never fail but potentially sacrifices finding novel scenes.
%POMS has the ability to find novel scenes, even when long range or global constraints are present, but at the cost
%of potential failure.

Gumin introduced the Wave Function Collapse (WFC) project which improved the block level solver used in MMS
and added facilities for automatic tile constraint deduction from exemplar scenes \cite{Gumin_2016}.
WFC uses a maximum entropy heuristic to choose which cells to resolve.
Though extensions are possible, WFC as presented by Gumin is a one-shot block level solver, giving up should a contradiction be encountered.

Since MMS is a grid level solver, other block level solvers can be used, such as WFC, to resolve underlying blocks,
with modifications added to allow for constraints, boundary conditions and other relevant features.
Merrell provides a comparison between MMS and WFC in \cite{Merrell_comparison_2021}.

Breakout Model Synthesis (BMS) was introduced in Hoetzlein's \texttt{just\_math} project \cite{Hoetzlein_2023}.
Hoetzlein's \texttt{just\_math} project also introduced
%The block level solver, Breakout Model Synthesis (BMS) was introduced in Hoetzlein's \texttt{just\_math} project \cite{Hoetzlein_2023},
the Tile Arc Consistent Correlation Length (TACCL) after noticing that knowledge of the tile correlation length could be
used to create algorithms that took advantage of it.
%In some sense, POMS, a grid level solver, is a natural extension of BMS, a block level solver, by allowing an ``out of core''
%algorithm.
%In some sense, POMS is a natural conversion of BMS from a block level solver to a grid level solver allowing an ``out of core''
%algorithm.
POMS takes the ideas of tile correlation and the TACCL to inform its backtracking strategies when applied to the larger grid
without needing the resource requirements that BMS, as a block level solver, would require.

%\begin{table}[h]
%  \label{table:CBTGComparison}
%  \centering
%  \begin{tabular}[t]{lccccc}
%    \hline
%    Algorithm & Solver Type & \specialcellCenter{Contradiction\\ Resiliance} & \specialcellCenter{Block Step \\ Consistent} & \specialcellCenter{Inderminate \\ Initial State} & Ergodic  \\
%    \hline
%    WFC  & Block & \textit{No}  & n/a         & \textbf{Yes} & \textbf{Yes} \\
%    BMS  & Block & \textbf{Yes} & n/a         & \textbf{Yes} & \textbf{Yes} \\
%    MMS  & Grid  & \textbf{Yes} & Yes         & \textit{No}  & \textit{No} \\
%    POMS & Grid  & \textbf{Yes} & \textit{No} & \textbf{Yes} & \textbf{Yes} \\
%    \hline
%  \end{tabular}
%  \caption{ \textbf{WFC}: Gumin's Wave Function Collapse \\ \textbf{BMS}: Breakout Model Synthesis \\ \textbf{MMS}: Merrell's Modify in Blocks Model Synthesis \\ \textbf{POMS}: Punch Out Model Synthesis (our algorithm) }
%\end{table}

\begin{table}[h]
  \label{table:CBTGComparison}
  \centering
  \begin{tabular}[t]{lcccc}
    \hline
     Algorithm & WFC & BMS & MMS & \textbf{POMS} \\
    \hline
    \specialcellCenter{Solver Type} & Block & Block & Grid & \textbf{Grid} \\
    \hline
    \specialcellCenter{Contradiction \\ \ \ Resiliance} & No & Yes & Yes & \textbf{Yes} \\
    \hline
    \specialcellCenter{Block Step \\ \ \ Consistent} & n/a & n/a & Yes & \textit{\textbf{No}} \\
    \hline
    \specialcellCenter{Indeterminate \\ \ \ Initial State} & Yes & Yes & No & \textbf{Yes} \\
    \hline
    \specialcellCenter{Ergodic} & Yes & Yes & No & \textbf{Yes} \\
    \hline
  \end{tabular}
  \caption{ \textbf{WFC}: Gumin's Wave Function Collapse \\ \textbf{BMS}: Breakout Model Synthesis \\ \textbf{MMS}: Merrell's Modify in Blocks Model Synthesis \\ \textbf{POMS}: Punch Out Model Synthesis (our algorithm) }
\end{table}

Table \ref{table:CBTGComparison} provides a summary of the differences between WFC, BMS, MMS and POMS.
Here, \textit{contradiction resiliance} means that the algorithm can recover should a contradiction be encountered,
\textit{block step consistent} means the algorithm is in an arc consistent state after every block resolution,
\textit{indeterminate initial state} means the algorithm doesn't require a fully resolved initial configuration and
\textit{ergodic} means that, in general, all solution states are possibly to reach.
Note that an assertion of being \textit{ergodic} in this context only means solutions
are possible and does not mean \textit{unbiased} as, depending on the tile constraints or configuration,
solution biasing may occur.
Punch Out Model Synthesis (POMS), the algorithm presented in this paper, is highlighted for ease of comparison.

In terms of algorithms to ensure arc consistency, MMS and WFC have used AC3 and AC4.
AC3 is easy to understand and can be performant if tile count is low but quickly suffers as tile count increases \cite{Wallace1993WhyAI}.
AC4 is optimal, in general, but requires large amounts of auxiliary space \cite{Mohr_Henderson_1986}.
POMS uses AC4 exclusively as tile count is often large (1,000 or more).


%Constraint Based Tiling Generation (CBTG)
CBTGs are a specialization of a more general Constraint Satisfaction Problem (CSP).
Karth and Smith offer some history of CSPs, some common concepts and algorithms in \cite{Karth_Smith_2017, Karth_Smith_2022}.
Of note is Karth and Smith's observation that shallow backtracking does little to help resolve conflicts.

%bad flow

%Two areas of research activity for Constraint Based Tiling Generation (CBTG) are attempts to make infinite CBTG algorithms
Two areas of research activity for CBTG are attempts to make infinite CBTG algorithms
and attempts at giving more control over created output.
%by providing facilities for hints or constraints in the resulting map.
Kleinberg provides an algorithm for infinite WFC by chaining blocks together \cite{Kleinberg_2019}.
While this can produce large scenes, the tile constraints are conditioned so that failure probability is low and Kleinberg admits
that block resolution can fail without any recourse on how to continue.

Newgas provides \texttt{Tessera}, a software project that implements WFC along with options for a variety of constraints \cite{Newgas_2021}.
Nie et all provide an extension to WFC to infinite grids but require the tile set to be \textit{complete} or \textit{sub-complete}
which may be difficult for tile sets in the wild \cite{Nie_etall_2023}.
Cooper introduces \texttt{Sturgeon} that incorporates a mid level API to specify more explicit and longer range constraints as an addition
to WFC \cite{Cooper_2022}.
Though Cooper's \texttt{Sturgeon} program and ideas look promising, the sizes involved are relatively small (40x40 and below)
and it's unclear how well the constraints would work on various tile sets, initial conditions or how well the method would scale
for larger level sizes.

Alaka and Bidarra attempt to offer more control over output level design by considering a user interface to group tiles and
weight individual tile probabilities into user specified regions \cite{Alaka_Bidarra_Rafael_2023}.
Langendam and Bidarra attempt to offer more control over output levels through a mixed initiative graphic tool that offers
the ability to interact with the underlying WFC solver in various ways \cite{Langendam_etall_2022}.

Of note is Lucas and Volz's straight forward application of counting tile frequency and measuring the Kullback-Leibler divergence
to attempt to get a better understanding of how biased the resulting generated map is \cite{Lucas_Volz_2019}.
Karth and Smith use a vector-quantized variational auto encoder (VQ-VAE) to create reduced tile domain maps which can then
be input into WFC to produce novel results \cite{Karth_Smith_2017}.

Automatic tile constraint creation from exemplar images was provided in Gumin's \textit{Wave Function Collapse} (WFC) project, \cite{Gumin_2016}.
Sherratt provides a good introduction to the pre processing step for automatic tile constraint creation in \cite{Sherratt_2019}.
Newgas offers a nice introduction to WFC and automatic tile constraint creation in \cite{BorisTheBrave_wfc_2021}.


